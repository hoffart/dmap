package de.jhoff.dmap;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.jhoff.dmap.util.map.CachingHashMap;
import de.jhoff.dmap.util.ByteArray;
import de.jhoff.dmap.util.ByteArrayUtils;

/**
 * Disk-backed implementation of a very simple Map that supports only 
 */
public class DMap {
  private static final int DMAP_VERSION = 1;

  private static final int DEFAULT_BLOCK_LIMIT = 3;

  /** Current Map file generated by Builder has Global trailer offset at 12. */
  private static final int DEFAULT_LOC_FOR_TRAILER_OFFSET = 12;

  /** Map file with data. */
  private File mapFile_;
  private RandomAccessFile raf_;
    
  /** Number of entries in the map. */
  private int size;

  /** Maximum number of blocks that can be used by dmap at a time. */
  private int maxBlockLimit_;

  /** First Key - Mapped block pair. */
  private Map<ByteArray, MappedByteBuffer>  cachedByteBuffers_;

  /** Mapping of first key of block to block's start offset. */
  private Map<ByteArray, Integer> firstKeyInBlock_;
  
  /** Mapping of block start offset to block trailer offset. */
  private Map<Integer, Integer> blockOffsetInfo_;

  /** Mapping of BlockTrailer Start offset and block trailer mapped bytebuffer of trailer*/
  private Map<Integer, MappedByteBuffer> blockTrailerBuffer;
  
  private Logger logger_ = LoggerFactory.getLogger(DMap.class);
    
  /**
   * Default constructor, will preload key/offsets but not the values.
   * 
   * @param mapFile Map file created by DMapBuilder
   * @throws IOException 
   */
  public DMap(File mapFile) throws IOException {
    this(mapFile, true, false, DEFAULT_BLOCK_LIMIT);
  }
  
  public DMap(File mapFile, int blockLimit) throws IOException{
    this(mapFile, true, false, blockLimit);
  }
  
  public DMap(File mapFile, boolean preloadOffsets, boolean preloadValues, int blockLimit) 
      throws IOException {
    mapFile_ = mapFile;
    maxBlockLimit_ = blockLimit;
    cachedByteBuffers_ = new CachingHashMap<>(maxBlockLimit_);
    raf_ = new RandomAccessFile(mapFile_, "r");

    int version = raf_.readInt();
    if(version != DMAP_VERSION) {
      throw new IOException("Invalid version of DMap file encountered. Please fix.");
    }

    // Sorted first keys
    firstKeyInBlock_ = new TreeMap<>();
    blockOffsetInfo_ = new HashMap<>();
    blockTrailerBuffer = new HashMap<>();

    size = raf_.readInt();
    
    if (preloadOffsets) {
      loadKeyDetails();
    }

    if (preloadValues) {      
      int numBlocks = getBlockCount();
      // override the maxBlockLimit_
      cachedByteBuffers_ = new CachingHashMap<>(numBlocks);
      for(ByteArray firstKey : firstKeyInBlock_.keySet()) {
        int blockStart = firstKeyInBlock_.get(firstKey);
        int blockTrailerStart = firstKeyInBlock_.get(blockStart);
        FileChannel fc = raf_.getChannel();
        MappedByteBuffer mappedBuffer_ = fc.map(MapMode.READ_ONLY, blockStart, blockTrailerStart - blockStart);
        cachedByteBuffers_.put(firstKey, mappedBuffer_);
      }
      logger_.debug("Preloaded all " + numBlocks + " blocks.");      
    }
  }
  
  private int getBlockCount() throws IOException {    
    int trailerOffset = getGlobalTrailerOffet();
    raf_.seek(trailerOffset);
    return raf_.readInt();
  }

  private int getGlobalTrailerOffet() throws IOException {
    raf_.seek(DEFAULT_LOC_FOR_TRAILER_OFFSET);
    return raf_.readInt();
  }
  
  private void loadKeyDetails() throws IOException {    
    int numBlocks = getBlockCount();
    logger_.info("Number of blocks in file : " + numBlocks);
    int blockStart;
    int blockTrailerStart;
    int prevBlockTrailerStart = -1;
    FileChannel fc;
    MappedByteBuffer trailerBuffer;
    for(int blockCount = 0; blockCount < numBlocks; ++blockCount) {
      blockStart = raf_.readInt();
      blockTrailerStart = raf_.readInt();
      int firstKeySize = raf_.readInt();
      byte[] firstKeyBytes = new byte[firstKeySize];
      raf_.read(firstKeyBytes);
      firstKeyInBlock_.put(new ByteArray(firstKeyBytes), blockStart);
      blockOffsetInfo_.put(blockStart, blockTrailerStart);
      if(blockCount > 0) {
        fc = raf_.getChannel();
        trailerBuffer = fc.map(MapMode.READ_ONLY, prevBlockTrailerStart, blockStart - prevBlockTrailerStart);
        //logger_.debug("Trailer starting at : " + prevBlockTrailerStart + " and ending at " + blockStart + " has size of : " + (blockStart - prevBlockTrailerStart));
        blockTrailerBuffer.put(prevBlockTrailerStart, trailerBuffer);        
      }
      prevBlockTrailerStart = blockTrailerStart;
      //logger_.debug("Loaded block starting at: " + blockStart + " with trailer at : " + blockTrailerStart);
    }
    int globalTrailerOffset = getGlobalTrailerOffet();
    fc = raf_.getChannel();
    trailerBuffer = fc.map(MapMode.READ_ONLY, prevBlockTrailerStart, globalTrailerOffset-prevBlockTrailerStart);
    //logger_.debug("Trailer starting at : " + prevBlockTrailerStart + " and ending at " + globalTrailerOffset + " has size of : " + (globalTrailerOffset - prevBlockTrailerStart));
    blockTrailerBuffer.put(prevBlockTrailerStart, trailerBuffer);
  }
  
  /**
   * Get the number of entries in the map.
   * 
   * @return Number of entries in the map.
   */
  public int size() {
    return size;
  }

  /**
   * Get byte[] value for key. TODO this could be made more efficient
   * by returning a reference to the original byte array in memory!
   * 
   * @param key Key to retrieve the value for.
   * @return  byte[] associated with key.
   */
  public byte[] get(byte[] key) throws IOException {
    if (firstKeyInBlock_ == null) {
      // TODO implement on-disk search.
      throw new IllegalStateException(
          "preloadOffsets has to be true in the constructor for now.");
    }
    ByteArray keyBytes = new ByteArray(key);
    logger_.debug("get(" + keyBytes + ") - hash: " + keyBytes.hashCode());
    ByteArray[] keys = new ByteArray[firstKeyInBlock_.size()];
    firstKeyInBlock_.keySet().toArray(keys);
    // identify the block containing the given key using first key information.
    ByteArray firstKeyBytes = ByteArrayUtils.findMaxElementLessThanTarget(keys, keyBytes);    

    if(firstKeyBytes == null) {
      // key not in range (less than start key)
      return null;
    }

    MappedByteBuffer mappedBuffer_;
    int blockStart = firstKeyInBlock_.get(firstKeyBytes);
    int blockTrailerStart = blockOffsetInfo_.get(blockStart);
    // trailer buffer
    mappedBuffer_ = blockTrailerBuffer.get(blockTrailerStart);
    // load the value offset
    Integer valueOffset = getValueOffset(keyBytes, mappedBuffer_);    
    if (valueOffset == null) {
      return null;
    }
    
    mappedBuffer_ = cachedByteBuffers_.get(firstKeyBytes);
    if(mappedBuffer_ == null) {
      FileChannel fc = raf_.getChannel();
      mappedBuffer_ = fc.map(MapMode.READ_ONLY, blockStart, blockTrailerStart - blockStart);
      cachedByteBuffers_.put(firstKeyBytes, mappedBuffer_);      
    }

    int valueLength = mappedBuffer_.getInt(valueOffset);
    byte[] value = new byte[valueLength];
    valueOffset += 4;
    for (int i = 0; i < value.length; ++i) {
      value[i] = mappedBuffer_.get(valueOffset);
      ++valueOffset;
    }    
    return value;
  }

  private synchronized Integer getValueOffset(ByteArray keyBytes, MappedByteBuffer mappedTrailerBuffer_) throws IOException {
    mappedTrailerBuffer_.rewind();
    int numKeysInBlock = mappedTrailerBuffer_.getInt();
    // logger_.debug("NUM KEYS : "  + numKeysInBlock);
    int valueOffset = -1;
    for(int count=0; count<numKeysInBlock; count++) {
      int keyLen = mappedTrailerBuffer_.getInt();
      byte[] currentkey = new byte[keyLen];
      mappedTrailerBuffer_.get(currentkey);
      ByteArray currentKeyBytes = new ByteArray(currentkey);      
      int offset = mappedTrailerBuffer_.getInt();
      // logger_.debug("Comparing " + keyBytes + " and " + currentKeyBytes + " : " + keyBytes.compareTo(currentKeyBytes));
      if(keyBytes.compareTo(currentKeyBytes) == 0) {
        valueOffset = offset;
        break;
      }
    }

    // key doesnt exist in the block
    if(valueOffset == -1) {
      return null;
    }    
    return valueOffset;
  }  
}