package de.jhoff.dmap;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import de.jhoff.dmap.util.map.CachingHashMap;
import de.jhoff.dmap.util.ByteArray;
import de.jhoff.dmap.util.ByteArrayUtils;

/**
 * Disk-backed implementation of a very simple Map that supports only 
 */
public class DMap {
  private static final int DMAP_VERSION = 1;

  private static final int DEFAULT_BLOCK_LIMIT = 3;

  /** Current Map file generated by Builder has Global trailer offset at 12. */
  private static final int DEFAULT_LOC_FOR_TRAILER_OFFSET = 12;

  /** Map file with data. */
  private File mapFile_;
  private RandomAccessFile raf_;
    
  /** Number of entries in the map. */
  private int size;

  /** Maximum number of blocks that can be used by dmap at a time. */
  private int maxBlockLimit_;

  /** First Key - Mapped block pair. */
  private Map<ByteArray, MappedByteBuffer>  cachedByteBuffers_;

  /** Mapping of first key of block to block's start offset. */
  private Map<ByteArray, Integer> firstKeyInBlock_;
  
  /** Mapping of block start offset to block trailer offset. */
  private Map<Integer, Integer> blockOffsetInfo_;

  /** Flag to enable/disable preloading of key offset pairs. */
  private boolean loadAllBlocksKeyOffsets;
  
  /** Mapping of BlockTrailer Start offset and block trailer mapped bytebuffer of trailer. */
  private Map<Integer, MappedByteBuffer> blockTrailerBuffer;
  
  /** Mapping of BlockTrailer start offset and all key-offset pairs info contained in the trailer. */
  private Map<Integer, Map<ByteArray, Integer>> blockTrailerKeys;
  
  private Logger logger_ = LoggerFactory.getLogger(DMap.class);
    
  /**
   * Default constructor, will preload key/offsets but not the values 
   * and limits number of blocks loaded to default of 3.
   * 
   * @param mapFile Map file created by DMapBuilder
   * @throws IOException 
   */
  public DMap(File mapFile) throws IOException {
    this(mapFile, true, false, DEFAULT_BLOCK_LIMIT);
  }
  
  /**
   * Creates a DMap for given mapFile and defaults to *blockLimit* number of blocks.
   * This constructor will preload all key-offset pairs but not the values.
   * 
   * @param mapFile
   * @param blockLimit
   * @throws IOException
   */
  public DMap(File mapFile, int blockLimit) throws IOException{
    this(mapFile, true, false, blockLimit);
  }
  
  /**
   * DMap constructor that allows to customize offset preloading.
   * Limits no. of blocks to default value 3 and does not load values in the memory.
   * 
   * @param mapFile
   * @param preloadOffsets
   * @throws IOException
   */
  public DMap(File mapFile, boolean preloadOffsets) 
      throws IOException {
    this(mapFile, preloadOffsets, false, DEFAULT_BLOCK_LIMIT);
  }
  
  /**
   * This constructor allows to customize both offset preloading and blocklimit.
   * Values will not be loaded by default.
   * 
   * @param mapFile
   * @param preloadOffsets
   * @param blockLimit
   * @throws IOException
   */
  public DMap(File mapFile, boolean preloadOffsets, int blockLimit) 
      throws IOException {
    this(mapFile, preloadOffsets, false, blockLimit);
  }

  /**
   * Allows to customize offset preloading, values preloading and block limits.
   * 
   * @param mapFile
   * @param preloadOffsets
   * @param preloadValues
   * @param blockLimit
   * @throws IOException
   */
  public DMap(File mapFile, boolean preloadOffsets, boolean preloadValues, int blockLimit) 
      throws IOException {
    mapFile_ = mapFile;
    maxBlockLimit_ = blockLimit;
    cachedByteBuffers_ = new CachingHashMap<>(maxBlockLimit_);
    raf_ = new RandomAccessFile(mapFile_, "r");

    int version = raf_.readInt();
    if(version != DMAP_VERSION) {
      throw new IOException("Invalid version of DMap file encountered. Please fix.");
    }

    loadAllBlocksKeyOffsets = preloadOffsets;
    
    // Sorted first keys
    firstKeyInBlock_ = new TreeMap<>();
    blockOffsetInfo_ = new HashMap<>();
    blockTrailerBuffer = new HashMap<>();
    blockTrailerKeys = new HashMap<>();

    size = raf_.readInt();
        
    loadKeyDetails();
    
    if (preloadValues) {      
      int numBlocks = getBlockCount();
      // override the maxBlockLimit_
      cachedByteBuffers_ = new CachingHashMap<>(numBlocks);
      for(ByteArray firstKey : firstKeyInBlock_.keySet()) {
        int blockStart = firstKeyInBlock_.get(firstKey);
        int blockTrailerStart = firstKeyInBlock_.get(blockStart);
        FileChannel fc = raf_.getChannel();
        MappedByteBuffer mappedBuffer_ = fc.map(MapMode.READ_ONLY, blockStart, blockTrailerStart - blockStart);
        cachedByteBuffers_.put(firstKey, mappedBuffer_);
      }
      logger_.debug("Preloaded all " + numBlocks + " blocks.");      
    }
  }

  /**
   * Get the number of entries in the map.
   * 
   * @return Number of entries in the map.
   */
  public int size() {
    return size;
  }

  /**
   * Get number of blocks in the map.
   * 
   * @return Number of blocks in the map.
   * @throws IOException
   */
  public int getBlockCount() throws IOException {    
    int trailerOffset = getGlobalTrailerOffet();
    raf_.seek(trailerOffset);
    return raf_.readInt();
  }

  /**
   * Get byte[] value for key. TODO this could be made more efficient
   * by returning a reference to the original byte array in memory!
   * 
   * @param key Key to retrieve the value for.
   * @return  byte[] associated with key.
   */
  public byte[] get(byte[] key) throws IOException {
    if (firstKeyInBlock_ == null) {
      // TODO implement on-disk search.
      throw new IllegalStateException(
          "preloadOffsets has to be true in the constructor for now.");
    }
    ByteArray keyBytes = new ByteArray(key);
    logger_.debug("get(" + keyBytes + ") - hash: " + keyBytes.hashCode());
    ByteArray[] keys = new ByteArray[firstKeyInBlock_.size()];
    firstKeyInBlock_.keySet().toArray(keys);
    // identify the block containing the given key using first key information.
    ByteArray firstKeyBytes = ByteArrayUtils.findMaxElementLessThanTarget(keys, keyBytes);    

    if(firstKeyBytes == null) {
      // key not in range (less than start key)
      return null;
    }

    MappedByteBuffer mappedBuffer_;
    int blockStart = firstKeyInBlock_.get(firstKeyBytes);
    int blockTrailerStart = blockOffsetInfo_.get(blockStart);
    // load the value offset
    Integer valueOffset = getValueOffset(keyBytes, blockTrailerStart);    
    if (valueOffset == null) {
      return null;
    }
    
    mappedBuffer_ = cachedByteBuffers_.get(firstKeyBytes);
    if(mappedBuffer_ == null) {
      FileChannel fc = raf_.getChannel();
      mappedBuffer_ = fc.map(MapMode.READ_ONLY, blockStart, blockTrailerStart - blockStart);
      cachedByteBuffers_.put(firstKeyBytes, mappedBuffer_);      
    }

    int valueLength = mappedBuffer_.getInt(valueOffset);
    byte[] value = new byte[valueLength];
    valueOffset += 4;
    for (int i = 0; i < value.length; ++i) {
      value[i] = mappedBuffer_.get(valueOffset);
      ++valueOffset;
    }    
    return value;
  }

  private synchronized Integer getValueOffset(ByteArray keyBytes, int blockTrailerStartOffset) throws IOException {
    int valueOffset = -1;    
    if(!loadAllBlocksKeyOffsets) {
      // time for linear search over the keys in block using mappedTrailer
      MappedByteBuffer mappedTrailerBuffer_ = blockTrailerBuffer.get(blockTrailerStartOffset);
      mappedTrailerBuffer_.rewind();
      int numKeysInBlock = mappedTrailerBuffer_.getInt();
      // logger_.debug("NUM KEYS : "  + numKeysInBlock);
      for(int count=0; count<numKeysInBlock; count++) {
        int keyLen = mappedTrailerBuffer_.getInt();
        byte[] currentkey = new byte[keyLen];
        mappedTrailerBuffer_.get(currentkey);
        ByteArray currentKeyBytes = new ByteArray(currentkey);      
        int offset = mappedTrailerBuffer_.getInt();
        // logger_.debug("Comparing " + keyBytes + " and " + currentKeyBytes + " : " + keyBytes.compareTo(currentKeyBytes));
        if(keyBytes.compareTo(currentKeyBytes) == 0) {
          valueOffset = offset;
          break;
        }
      }
    } else {
      // just look up in the existing map
      Map<ByteArray, Integer> tmpMap = blockTrailerKeys.get(blockTrailerStartOffset);
      if(tmpMap != null && tmpMap.containsKey(keyBytes)) {
        valueOffset = tmpMap.get(keyBytes);        
      }      
    }

    // key doesnt exist in the block
    if(valueOffset == -1) {
      return null;
    }    
    return valueOffset;
  }
  
  private int getGlobalTrailerOffet() throws IOException {
    raf_.seek(DEFAULT_LOC_FOR_TRAILER_OFFSET);
    return raf_.readInt();
  }
  
  private void processBlockTrailer(int trailerStartOffset, int trailerSize) throws IOException {
    FileChannel fc = raf_.getChannel();
    MappedByteBuffer trailerBuffer = fc.map(MapMode.READ_ONLY, trailerStartOffset, trailerSize);
    if(!loadAllBlocksKeyOffsets) {      
      blockTrailerBuffer.put(trailerStartOffset, trailerBuffer);
    } else {
      int numKeysInBlock = trailerBuffer.getInt();
      Map<ByteArray, Integer> tmpKeyOffsetMap = new HashMap<>();
      for(int count=0; count<numKeysInBlock; count++) {
        int keyLen = trailerBuffer.getInt();
        byte[] currentkey = new byte[keyLen];
        trailerBuffer.get(currentkey);
        ByteArray currentKeyBytes = new ByteArray(currentkey);      
        int offset = trailerBuffer.getInt();
        tmpKeyOffsetMap.put(currentKeyBytes, offset);
      }
      blockTrailerKeys.put(trailerStartOffset, tmpKeyOffsetMap);
    }
  }
  
  private void loadKeyDetails() throws IOException {    
    int numBlocks = getBlockCount();
    logger_.info("Number of blocks in file : " + numBlocks);
    int blockStart;
    int blockTrailerStart;
    int prevBlockTrailerStart = -1;

    for(int blockCount = 0; blockCount < numBlocks; ++blockCount) {
      blockStart = raf_.readInt();
      blockTrailerStart = raf_.readInt();
      int firstKeySize = raf_.readInt();
      byte[] firstKeyBytes = new byte[firstKeySize];
      raf_.read(firstKeyBytes);
      firstKeyInBlock_.put(new ByteArray(firstKeyBytes), blockStart);
      blockOffsetInfo_.put(blockStart, blockTrailerStart);
      if(blockCount > 0) {
        // compute the previous block's trailer size and store the information
        processBlockTrailer(prevBlockTrailerStart, blockStart - prevBlockTrailerStart);               
      }
      prevBlockTrailerStart = blockTrailerStart;
    }
    processBlockTrailer(prevBlockTrailerStart, getGlobalTrailerOffet()-prevBlockTrailerStart);    
  }
}